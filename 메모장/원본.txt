
-- DDL (아직 신경쓰지 말 것) --

DROP TABLE Book;
CREATE TABLE Book(
	bookid INT,
	bookname VARCHAR(30),
	publisher VARCHAR(30),
	price INT
);

DROP TABLE Orders;
CREATE TABLE Orders(
	orderid INT,
	custid INT,
	bookid INT,
	saleprice INT,
	orderdate DATETIME
);

DROP TABLE Customer;
CREATE TABLE Customer(
	custid INT,
	name VARCHAR(20),
	address VARCHAR(200),
	phone VARCHAR(30)
);

-- SQL: DML, DDL, DCL 이 있지만,
-- DML의 SELECT만 정복하면 나머지는 알아서 해결된다.

-- 이게 mariaDB 주석
SELECT now();

SELECT 1234;

-- DML: 데이터 조작언어 (CRUD)
-- INSERT, SELECT, UPDATE, DELETE

-- INSERT
INSERT INTO Book(bookid, bookname, publisher, price) VALUES
(1, '축구의 역사', '굿스포츠', 7000),
(2, '축구아는 여자', '나무수', 13000),
(3, '축구의 이해', '대한미디어', 22000),
(4, '골프 바이블', '대한미디어', 35000),
(5, '피겨 교본', '굿스포츠', 8000),
(6, '역도 단계별기술', '굿스포츠', 6000),
(7, '야구의 추억', '이상미디어', 20000),
(8, '야구를 부탁해', '이상미디어', 13000),
(9, '올림픽 이야기', '삼성당', 7500),
(10, 'Olympic Champions', 'Pearson', 13000);

INSERT INTO Orders(orderid, custid, bookid, saleprice, orderdate) VALUES
(1, 1, 1, 6000, '2014-07-01'),
(2, 1, 3, 21000, '2014-07-03'),
(3, 2, 5, 8000, '2014-07-03'),
(4, 3, 6, 6000, '2014-07-04'),
(5, 4, 7, 20000, '2014-07-05'),
(6, 1, 2, 12000, '2014-07-07'),
(7, 4, 8, 13000, '2014-07-07'),
(8, 3, 10, 12000, '2014-07-08'),
(9, 2, 10, 7000, '2014-07-09'),
(10, 3, 8, 13000, '2014-07-10');

INSERT INTO Customer(custid, name, address, phone) VALUES
(1, '박지성', '영국 맨체스터', '000-5000-0001'),
(2, '김연아', '대한민국 서울', '000-6000-0001'),
(3, '장미란', '대한민국 강원도', '000-7000-0001'),
(4, '추신수', '미국 클리블랜드', '000-8000-0001'),
(5, '박세리', '대한민국 대전', NULL);



SELECT * FROM Book; -- 이걸로 Book을 불러올 수 있다.(상태 확인)
SELECT * FROM Orders;
SELECT * FROM Customer;

-- 모든 도서의 이름과 가격을 검색하세요!

SELECT bookname,price FROM Book;

-- 모든 도서의 도서번호 도서이름 출판사 가격을 검색하세요!

SELECT bookid,bookname,publisher,price FROM Book;

-- 도서 테이블에 있는 모든 출판사를 검색하고, 중복을 제거하세요.

SELECT publisher FROM Book;
SELECT DISTINCT publisher FROM Book;	-- DISTINCT: 중복 제거 문법

-- 가격이 2만원 미만인 도서를 검색하세요.

SELECT * FROM Book WHERE price < 20000;

-- 가격이 1만원 이상, 2만원 이하인 도서를 검색하세요.

SELECT * FROM Book WHERE 10000<= price AND price <= 20000;


-- !중요! IN 문법. --
-- 출판사가 굿스포츠, 대한미디어인 도서를 검색하세요.

SELECT * FROM Book WHERE publisher = '굿스포츠' OR publisher = '대한미디어';
SELECT * FROM Book WHERE publisher IN('굿스포츠', '대한미디어');	-- 이렇게 하는게 정답!
SELECT * FROM Book WHERE publisher NOT IN('나무수','이상미디어', '삼성당', 'Pearson');
SELECT * FROM Book WHERE publisher LIKE '굿스포츠' OR publisher LIKE '대한미디어';

-- 축구의 역사를 출판한 출판사를 검색하세요.

SELECT bookname, publisher FROM Book WHERE bookname LIKE '축구의 역사';

-- 도서 이름에 '축구'가 포함된 책을 출판한 출판사를 검색하세요.

SELECT * FROM Book WHERE bookname LIKE '%축구%';

-- 도서 이름의 왼쪽 두 번째 위치에 '구'라는 문자열을 갖는 도서를 검색하세요.

SELECT * FROM Book WHERE bookname LIKE '_구%';

-- 성이 '김'씨인 사람을 검색하세요.

SELECT * FROM Customer WHERE name LIKE '김%';

-- '축구'라는 단어가 제목에 들어간 도서 중, 가격이 2만원 이상인 도서를 검색하세요.

SELECT * FROM Book WHERE bookname Like '%축구%' AND price >= 20000;

-- 출판사가 '굿스포츠' 혹은 '대한미디어' 인 도서를 검색하세요.

SELECT bookname, publisher FROM Book WHERE publisher = '굿스포츠' OR publisher = '대한미디어';

-- 도서를 이름순으로 검색하세요.

SELECT * FROM Book ORDER BY bookname ASC;
SELECT * FROM Book ORDER BY bookname DESC;	-- 오름차순, 내림차순 기본이 오름차순이다. 즉, ASC를 그냥 안 쓰면 오름차순이다.
-- 실무에서는 최신순으로 표현하는 일이 많기 때문에, 내림차순을 쓴다. 보통 최근에 추가한 게 넘버링이 크기 때문에.

-- 도서를 높은 가격순으로 검색하고, 만약 가격이 같다면 이름순으로 검색하세요.

SELECT * FROM Book ORDER BY price ASC,bookname ASC;

-- 고객이 주문한 도서의 총 판매액을 구하세요.

SELECT SUM(saleprice) FROM Orders;	-- 이때 saleprice는 벡터고, 그걸 sum한 값은 스칼라다. 따라서 SUM(여기에다가 벡터를 넣어야 한다.)

-- 김연아(2번) 회원이 구매한 도서의 총 판매액을 구하세요.

SELECT SUM(saleprice) FROM Orders WHERE custid = 2;

-- 고객이 주문한 도서의 총 판매액, 평균값, 최저가, 최고가를 구하세요.

SELECT SUM(saleprice), AVG(saleprice), MIN(saleprice), MAX(saleprice) FROM Orders ;

-- 마당 서점의 도서 판매 건수를 구하세요.

SELECT COUNT(*) FROM Orders;	-- 일반적으로 COUNT는 *을 쓴다.

-- 마당 서점의 도서 판매 건수를 구하고, 그 명칭을 'OrderCount' 로 표현하세요.

SELECT COUNT(*) AS OrderCount FROM Orders;

-- GROUP BY 문법
-- 고객별로 주문한 도서의 총 수량과 총 판매액을 구하세요.

SELECT custid, COUNT(*), SUM(saleprice) FROM Orders GROUP BY custid;
-- GROUP BY 를 쓸 때는, SELECT 뒤에 맨 처음 쓰는 필드는 무조건 GROUP BY 뒤에 오는 필드(벡터)값 한 개만 쓴다. 나머지는 무조건 스칼라값으로.

-- 도서별 판매량과 총 매출액을 구하세요.

SELECT bookid, COUNT(*) AS 판매량, SUM(saleprice) FROM Orders
GROUP BY Bookid
;

-- 가격이 8000원 이상인 도서를 구매한 고객에 대하여 고객별 주문 도서의 총 수량을 구하세요. 단, 2권 이상 구매한 고객만 구하세요.
-- GROUP BY로 묶은 뒤에는 GROUP BY 뒤에 바로 쓰인 벡터를 제외하고는 추가로 벡터를 더 쓰면 안 되고 반드시 스칼라를 써야한다.
-- 위에랑 똑같은 얘기. 그냥 외우면 된다. (사실 어떻게 보면 당연한 것.)
SELECT custid ,COUNT(*) AS "주문한 도서의 총 수량" 
FROM Orders
WHERE saleprice >= 8000
GROUP BY custid
HAVING COUNT(*) >= 2
;

SELECT qwer.* FROM Orders qwer ;
SELECT o.* FROM Orders o ;	-- 이렇게 별칭을 붙이고 쓸 수 있다.

-- INNER JOIN 문법.

SELECT * FROM Customer c, Orders o WHERE c.custid = o.custid ;	-- 이렇게 여러개의 테이블을 하나로 JOIN 해서 SELECT 할 수 있다.

-- 고객별 주문한 책 로그
SELECT c.name, b.bookname, b.price, o.saleprice
FROM Customer c, Orders o, Book b
WHERE c.custid = o.custid AND o.bookid = b.bookid
ORDER BY c.name;

-- INNER JOIN - ANSI 조인 위처럼 쉼표로 하지 않고 INNER JOIN을 써서 가독성을 높인다.
SELECT *
FROM Orders o
INNER JOIN Customer c ON c.custid = o.custid
WHERE c.name = '박지성';

SELECT c.name, b.bookname, b.price, o.saleprice
FROM Orders o
INNER JOIN Book b ON o.bookid = b.bookid 
INNER JOIN Customer c ON o.custid = c.custid
;

-- 고객과 고객의 주문에 관한 데이터를 모두 보이세요.

SELECT *
FROM Customer c 
INNER JOIN Orders o ON o.custid = c.custid
ORDER BY c.custid 
;

-- 고객의 이름과 고객이 주문한 도서의 판매가격을 검색하세요.

SELECT c.name, o.saleprice
FROM Orders o 
INNER JOIN Customer c ON c.custid = o.custid 
;

-- 고객별로 주문한 모든 도서의 총 판매액을 구하고, 고객별로 정렬하세요.

SELECT c.name, SUM(o.saleprice) FROM Orders o 
INNER JOIN Customer c ON c.custid = o.custid 
GROUP BY c.name
ORDER BY c.name
;	-- 이렇게 짜버리면 동명이인이 있을 경우, 잘못된 리턴값이 나오기 때문에

SELECT c.custid, c.name, SUM(o.saleprice)
FROM Orders o 
INNER JOIN Customer c ON c.custid = o.custid 
GROUP BY c.custid, c.name
ORDER BY c.custid 
;

-- 고객의 이름과 고객이 주문한 도서의 이름을 구하세요.

SELECT c.name, b.bookname FROM Customer c 
INNER JOIN Orders o ON c.custid = o.custid 
INNER JOIN Book b ON o.bookid  = b.bookid 
;

-- 가격이 2만원인 도서를 주문한 고객의 이름과 도서의 이름을 구하세요.

SELECT c.name, b.bookname
FROM Customer c 
INNER JOIN Orders o ON c.custid = o.custid 
INNER JOIN Book b ON o.bookid  = b.bookid 
WHERE b.price >= 20000
;

-- 도서를 구매하지 않은 고객을 포함하여 고객의 이름과 고객이 주무한 도서의 판매액을 구하세요.
-- (외부 조인 문법. OUTER JOIN)
SELECT c.name, o.saleprice
FROM Orders o 
INNER JOIN Customer c ON c.custid = o.custid 
;	-- 이 경우, 도서를 구매하지 않은 박세리는 조회가 되지 않는다. 따라서,
SELECT c.name, o.saleprice
FROM Customer c
LEFT OUTER JOIN Orders o ON o.custid = c.custid 
	-- Customer 을 기준으로 조인이 됐기 때문에 박세리도 출력된다. 만약 c랑 o를 바꿔서 조인하면 오더 테이블에 커스터머가 붙는 거기 때문에 이너조인과 같다.
;

-- 부속 질의(서브쿼리)

SELECT (SELECT 1111)
FROM (
	SELECT * FROM Book b
) aaa
WHERE aaa.bookid = (SELECT 3333)
;	-- 이렇게 SELECT, FROM, WHERE 등 안에 SELECT를 쓸 수 있다. 

-- 가장 비싼 도서의 정보를 구하세요.

SELECT * FROM Book b WHERE b.price;
SELECT MAX(b.price) FROM Book b ;	-- 이 두개의 정보를 합치면 질문에 대한 답이 된다.

SELECT *
FROM Book b
WHERE b.price = (
	SELECT MAX(b2.price)
	FROM Book b2
);	
-- 이렇게
SELECT o.saleprice FROM Orders o;
SELECT * FROM Book b WHERE b.price > ALL(SELECT o.saleprice FROM Orders o) ;
SELECT * FROM Book b WHERE b.price > ANY(SELECT o.saleprice FROM Orders o) ;

-- 도서를 구매한 적이 있는 고객의 이름을 검색하세요.

SELECT c.name FROM Customer c 
WHERE c.custid IN(SELECT o.custid FROM Orders o);

-- '대한미디어'에서 출판한 도서를 구매한 고객의 정보를 보이세요.

SELECT * FROM Customer c 
WHERE c.custid IN(
	SELECT o.custid FROM Orders o WHERE o.bookid IN(
		SELECT b.bookid FROM Book b WHERE b.publisher = '대한미디어'
	)
)
;

SELECT b.bookid FROM Book b WHERE b.publisher = '대한미디어' ;
-- 이런 문제 풀 때는, 한 번에 넣는게 아니라 하나하나 뜯어서 생각하고 조립해야 한다. --

-- 출판사별로 출판사의 평균 도서 가격보다 비싼 도서를 구하세요.

SELECT * FROM Book b
WHERE b.price > (
	SELECT AVG(b2.price)
	FROM Book b2
	WHERE b2.publisher = b.publisher 
)
;
SELECT AVG(b2.price) FROM Book b2 WHERE b2.publisher = '나무수';

-- 주문이 있는 고객의 이름과 주소를 보이세요. EXISTS 문법.

SELECT c.name, c.address FROM Customer c
WHERE EXISTS(	-- EXISTS 안에 결과가 존재하면 true, 아니면 false
	SELECT * FROM Orders o WHERE o.custid = c.custid 	
)
;

-- 도서를 주문하지 않은 고객의 이름을 보이세요.

SELECT c.name  
FROM Customer c
LEFT JOIN Orders o ON c.custid = o.custid  
WHERE o.orderid IS NULL
; 




-- 함수 .

-- 내장 함수 연습 - 어차피 다 못외우기 때문에 api처럼 그때 그때 찾아서 쓴다. 그럼에도 자주 쓰는 걸 보자면

SELECT b.price/3 FROM Book b ;
-- 이렇게 하면 소수점이 너무 많아서 보기 불편하니까

SELECT ROUND(b.price/3) FROM Book b ;
-- 이것도 숫자가 깔끔하지 않으니까 추가로 반올림이나 버림을 한다

SELECT ROUND(b.price/3, -2) FROM Book b ;
-- 사실 반올림(ROUND) 보단 실무에선 버림(TRUNCATE)이 더 많이 쓰인다. ex. 20대, 30대, 등등...
SELECT TRUNCATE(b.price/3, -2) FROM Book b ;

-- 또 자주 쓰이는 것. CONCAT. 문자열 연산. JAVA에서는 그냥 + 로 문자열을 붙일 수 있었지만...

SELECT *
FROM Book b 
WHERE b.bookname LIKE '%축구%';
-- 보안 이슈 때문에 실무에서는 LIKE를 이렇게 쓰진 않고,
SELECT *
FROM Book b 
WHERE b.bookname LIKE CONCAT('%', '축구', '%') ;
-- 이렇게 쓴다. 이건 그냥 무조건 다 이렇게 하는거라 외우면 된다.


-- NOW(); 현재 시간을 표시.

SELECT *
FROM Orders o 
WHERE o.orderdate < NOW() ;

-- 판매량 베스트 3 도서
SELECT b.bookid , b.bookname , COUNT(*) AS '도서별 판매 수량'
FROM Orders o 
INNER JOIN Book b ON b.bookid = o.bookid
GROUP BY b.bookid, b.bookname 
ORDER BY COUNT(*) DESC
LIMIT 3
;

-- 판매량 베스트 3 도서 (최근 7일 기준)
SELECT b.bookid , b.bookname , COUNT(*) AS '도서별 판매 수량'
FROM Book b
INNER JOIN Orders o ON o.bookid = b.bookid 
WHERE o.orderdate > DATE_SUB(NOW(), INTERVAL 7 DAY)
GROUP BY b.bookid, b.bookname
ORDER BY COUNT(*) DESC
LIMIT 3
;

SELECT *
FROM Customer c
WHERE c.phone IS NULL
;

-- 만약 구매가격에 NULL 값이 있는 경우, 합산 구하기
SELECT IFNULL(c.phone, 'qwer')
FROM Customer c ;

SELECT SUM(IFNULL(o.saleprice, 0))
FROM Orders o ;
-- 이렇게 null값이면 값을 대체할 수 있다.

-- ROWNUM의 가장 흔한 용도는 쿼리 결과의 상위 몇 개만 가져오는 것입니다. MariaDB에서는 이를 위해 LIMIT 절을 사용합니다.
-- 가격이 가장 비싼 상위 3개 도서를 검색 (ROWNUM < 4와 동일한 효과)
SELECT *
FROM Book
ORDER BY price DESC  -- 반드시 정렬 후 LIMIT을 적용해야 의미가 있음
LIMIT 3;



-- 인라인뷰. FROM 부속질의 ---------------------------------


SELECT o.custid, SUM(o.saleprice) AS '총 판매액'
FROM Orders o
GROUP BY o.custid 
;
-- 이 데이터를 테이블처럼 묶어서 FROM 안에 넣을 수 있다.(FROM 부속질의)

SELECT * FROM (
	SELECT o.custid, SUM(o.saleprice) AS qwer
	FROM Orders o
	GROUP BY o.custid 
) t1 ;
-- 이렇게. 그리고 별칭을 붙여서 메서드처럼 쓸 수 있다.
SELECT * FROM (
	SELECT o.custid, SUM(o.saleprice) AS qwer
	FROM Orders o
	GROUP BY o.custid 
) t1
WHERE t1.qwer > 20000
;	-- 이렇게. WHERE을 안에 쓴 것과 차이점은, 괄호 안의 계산이 전부 끝난 뒤에 실행한다는 점이다.


-- 총 구매액이 20000원 이상인 고객의 판매액을 보이세요(고객 이름과 고객별 판매액 출력)

SELECT c.name, t1.qwer FROM (
	SELECT o.custid, SUM(o.saleprice) as qwer
	FROM Orders o 
	GROUP BY o.custid
	-- HAVING SUM(o.salepric) > 20000 --> 원래 이렇게 했었다.
) t1
INNER JOIN Customer c ON c.custid  = t1.custid 
WHERE t1.qwer > 20000
;


-- 스칼라 부속질의 - SELECT 부속질의 ---------
-- 마당서점의 고객별 판매액을 보이세요.

SELECT o.custid , SUM(o.saleprice)
FROM Orders o 
GROUP BY o.custid 
; -- 이 코드를 custid로 하는 이유는, 동명이인이나 중복될 염려가 있기 때문인데,

SELECT c.name FROM Customer c WHERE c.custid = 1;
-- 이 코드는 같은 c.name이지만 WHERE 조건으로 단 한가지의 조건으로 국한해었기 때문에 이 코드를 위에다 넣으면 된다.

SELECT (
	SELECT c.name FROM Customer c WHERE c.custid = o.custid
	) as qwer, SUM(o.saleprice)
FROM Orders o 
GROUP BY o.custid 
; -- 이렇게 하면 SELECT 안 쪽이 유일한 c.name이 된다. 주의할 점은 반드시 스칼라값만 넣을 수 있다.


-- 아무것도 구매하지 않은 고객을 포함하여 고객별 판매액과 수량을 구하세요. (GROUP BY를 안 쓰고)

SELECT c.*, (
	SELECT COUNT(*) FROM Orders o WHERE o.custid = c.custid
) as cnt, (
	SELECT SUM(o.saleprice) FROM Orders o WHERE o.custid = c.custid
) as total
FROM Customer c 
;	-- 이렇게 SELECT 부속질의(주의. 스칼라만 가능)를 계속 써서 GROUP BY처럼 표현할 수 있다. 단점은 처리속도가 GROUP BY에 비해 느리다.

-- 평균 주문금액 이하의 주문에 대하여 주문번호와 금액을 보이세요.
SELECT *
FROM Orders o 
WHERE o.saleprice <= (SELECT AVG(o2.saleprice) FROM Orders o2)
;	-- 이때 WHERE <= 뒤에 오는 값은 당연히 스칼라값이어야 한다.

-- 각 고객의 평균 주문 금액보다 큰 금액의 주문 내역에 대해서 주문번호, 고객번호, 금액을 보이세요.
SELECT *
FROM Orders o 
WHERE o.saleprice > (
	SELECT AVG(o2.saleprice) FROM Orders o2 WHERE o2.custid = o.custid
);

-- '대한민국'에 거주하는 고객에게 판매한 도서의 총판매액을 구하세요.
SELECT SUM(o.saleprice) 
FROM Orders o 
WHERE o.custid IN (qwer)
;	-- 여기서 qwer 안에 '대한민국'에 사는 고객 넣으면 된다.

SELECT c.custid FROM Customer c WHERE c.address LIKE '%대한민국%';

SELECT SUM(o.saleprice) 
FROM Orders o 
WHERE o.custid IN (
	SELECT c.custid FROM Customer c WHERE c.address LIKE '%대한민국%'
);

-- 3번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 금액을 보이세요.
SELECT * FROM Orders o 
WHERE o.saleprice > 0000;	-- 0000 안에 이제 조건에 맞는 코드를 넣으면 된다.

SELECT o2.saleprice FROM Orders o2 WHERE o2.custid = 3 -- 이걸 그대로 넣으면 타입오류가 떠서 ALL을 붙인다.

SELECT * FROM Orders o 
WHERE o.saleprice > ALL(SELECT o2.saleprice FROM Orders o2 WHERE o2.custid = 3)
;	-- 이렇게.

-- EXISTS 를 써서 '대한민국'에 거주하는 고객에게 판매한 도서의 총판매액을 구하세요.
SELECT SUM(o.saleprice) FROM Orders o
WHERE EXISTS ( 
	SELECT * FROM Customer c
	WHERE c.address LIKE '%대한민국%' AND c.custid = o.custid 
);










